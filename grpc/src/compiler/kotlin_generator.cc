/*
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "src/compiler/kotlin_generator.h"

#include <algorithm>
#include <iostream>
#include <iterator>
#include <map>
#include <utility>
#include <vector>

#include "flatbuffers/util.h"
#define to_string flatbuffers::NumToString

// Stringify helpers used solely to cast GRPC_VERSION
#ifndef STR
#  define STR(s) #  s
#endif

#ifndef XSTR
#  define XSTR(s) STR(s)
#endif

typedef grpc_generator::Printer Printer;
typedef std::map<grpc::string, grpc::string> VARS;
typedef grpc_generator::Service ServiceDescriptor;
typedef grpc_generator::CommentHolder
    DescriptorType;  // base class of all 'descriptors'
typedef grpc_generator::Method MethodDescriptor;

namespace grpc_kotlin_generator {
typedef std::string string;
namespace {
// Generates imports for the service
static void GenerateImports(grpc_generator::File *file,
                     grpc_generator::Printer *printer, VARS &vars) {
  vars["filename"] = file->filename();
  printer->Print(vars,
                 "//Generated by flatc compiler (version $flatc_version$)\n");
  printer->Print("//If you make any local changes, they will be lost\n");
  printer->Print(vars, "//source: $filename$.fbs\n\n");
  printer->Print(vars, "package $Package$;\n\n");
  vars["Package"] = vars["Package"] + ".";
  if (!file->additional_headers().empty()) {
    printer->Print(file->additional_headers().c_str());
    printer->Print("\n\n");
  }
}

// Adjust a method name prefix identifier to follow the JavaBean spec:
//   - decapitalize the first letter
//   - remove embedded underscores & capitalize the following letter
static string MixedLower(const string &word) {
  string w;
  w += static_cast<string::value_type>(tolower(word[0]));
  bool after_underscore = false;
  for (size_t i = 1; i < word.length(); ++i) {
    if (word[i] == '_') {
      after_underscore = true;
    } else {
      w += after_underscore ? static_cast<string::value_type>(toupper(word[i]))
                            : word[i];
      after_underscore = false;
    }
  }
  return w;
}

// Converts to the identifier to the ALL_UPPER_CASE format.
//   - An underscore is inserted where a lower case letter is followed by an
//     upper case letter.
//   - All letters are converted to upper case
static string ToAllUpperCase(const string &word) {
  string w;
  for (size_t i = 0; i < word.length(); ++i) {
    w += static_cast<string::value_type>(toupper(word[i]));
    if ((i < word.length() - 1) && islower(word[i]) && isupper(word[i + 1])) {
      w += '_';
    }
  }
  return w;
}

static inline string LowerMethodName(const MethodDescriptor *method) {
  return MixedLower(method->name());
}

static inline string MethodPropertiesFieldName(const MethodDescriptor *method) {
  return "METHOD_" + ToAllUpperCase(method->name());
}

static inline string MethodPropertiesGetterName(
    const MethodDescriptor *method) {
  return MixedLower(method->name() + "_method_descriptor");
}

static inline string MethodIdFieldName(const MethodDescriptor *method) {
  return "METHODID_" + ToAllUpperCase(method->name());
}

static inline string KotlinClassName(VARS &vars, const string &name) {
  return vars["Package"] + name;
}

static inline string ServiceObjectName(const string &service_name) {
  return service_name + "Grpc";
}

static inline string ServiceKtObjectName(const string &service_name) {
  return service_name + "GrpcKt";
}

static inline string WrapFlow(VARS &vars, const string &type_name) {
  return vars["Flow"]+"<"+type_name+">";
}

// TODO(nmittler): Remove once protobuf includes ktdoc methods in
// distribution.
template<typename ITR>
static void GrpcSplitStringToIteratorUsing(const string &full,
                                           const char *delim, ITR &result) {
  // Optimize the common case where delim is a single character.
  if (delim[0] != '\0' && delim[1] == '\0') {
    char c = delim[0];
    const char *p = full.data();
    const char *end = p + full.size();
    while (p != end) {
      if (*p == c) {
        ++p;
      } else {
        const char *start = p;
        while (++p != end && *p != c)
          ;
        *result++ = string(start, p - start);
      }
    }
    return;
  }

  string::size_type begin_index, end_index;
  begin_index = full.find_first_not_of(delim);
  while (begin_index != string::npos) {
    end_index = full.find_first_of(delim, begin_index);
    if (end_index == string::npos) {
      *result++ = full.substr(begin_index);
      return;
    }
    *result++ = full.substr(begin_index, (end_index - begin_index));
    begin_index = full.find_first_not_of(delim, end_index);
  }
}

static void GrpcSplitStringUsing(const string &full, const char *delim,
                                 std::vector<string> *result) {
  std::back_insert_iterator<std::vector<string>> it(*result);
  GrpcSplitStringToIteratorUsing(full, delim, it);
}

static std::vector<string> GrpcSplit(const string &full, const char *delim) {
  std::vector<string> result;
  GrpcSplitStringUsing(full, delim, &result);
  return result;
}

// TODO(nmittler): Remove once protobuf includes ktdoc methods in
// distribution.
static string GrpcEscapeKtdoc(const string &input) {
  string result;
  result.reserve(input.size() * 2);

  char prev = '*';

  for (string::size_type i = 0; i < input.size(); i++) {
    char c = input[i];
    switch (c) {
      case '*':
        // Avoid "/*".
        if (prev == '/') {
          result.append("&#42;");
        } else {
          result.push_back(c);
        }
        break;
      case '/':
        // Avoid "*/".
        if (prev == '*') {
          result.append("&#47;");
        } else {
          result.push_back(c);
        }
        break;
      case '@':
        // '@' starts ktdoc tags including the @deprecated tag, which will
        // cause a compile-time error if inserted before a declaration that
        // does not have a corresponding @Deprecated annotation.
        result.append("&#64;");
        break;
      case '<':
        // Avoid interpretation as HTML.
        result.append("&lt;");
        break;
      case '>':
        // Avoid interpretation as HTML.
        result.append("&gt;");
        break;
      case '&':
        // Avoid interpretation as HTML.
        result.append("&amp;");
        break;
      case '\\':
        // Java interprets Unicode escape sequences anywhere!
        result.append("&#92;");
        break;
      default: result.push_back(c); break;
    }

    prev = c;
  }

  return result;
}

static std::vector<string> GrpcGetDocLines(const string &comments) {
  if (!comments.empty()) {
    // TODO(kenton):  Ideally we should parse the comment text as Markdown and
    //   write it back as HTML, but this requires a Markdown parser.  For now
    //   we just use <pre> to get fixed-width text formatting.

    // If the comment itself contains block comment start or end markers,
    // HTML-escape them so that they don't accidentally close the doc comment.
    string escapedComments = GrpcEscapeKtdoc(comments);

    std::vector<string> lines = GrpcSplit(escapedComments, "\n");
    while (!lines.empty() && lines.back().empty()) { lines.pop_back(); }
    return lines;
  }
  return std::vector<string>();
}

static std::vector<string> GrpcGetDocLinesForDescriptor(
    const DescriptorType *descriptor) {
  return descriptor->GetAllComments();
}

static void GrpcWriteDocCommentBody(Printer *printer, VARS &vars,
                                    const std::vector<string> &lines,
                                    bool surroundWithPreTag) {
  if (!lines.empty()) {
    if (surroundWithPreTag) { printer->Print(" * <pre>\n"); }

    for (size_t i = 0; i < lines.size(); i++) {
      // Most lines should start with a space.  Watch out for lines that start
      // with a /, since putting that right after the leading asterisk will
      // close the comment.
      vars["line"] = lines[i];
      if (!lines[i].empty() && lines[i][0] == '/') {
        printer->Print(vars, " * $line$\n");
      } else {
        printer->Print(vars, " *$line$\n");
      }
    }

    if (surroundWithPreTag) { printer->Print(" * </pre>\n"); }
  }
}

static void GrpcWriteDocComment(Printer *printer, VARS &vars,
                                const string &comments) {
  printer->Print("/**\n");
  std::vector<string> lines = GrpcGetDocLines(comments);
  GrpcWriteDocCommentBody(printer, vars, lines, false);
  printer->Print(" */\n");
}

static void GrpcWriteServiceDocComment(Printer *printer, VARS &vars,
                                       const ServiceDescriptor *service) {
  printer->Print("/**\n");
  std::vector<string> lines = GrpcGetDocLinesForDescriptor(service);
  GrpcWriteDocCommentBody(printer, vars, lines, true);
  printer->Print(" */\n");
}

static void GrpcWriteMethodDocComment(Printer *printer, VARS &vars,
                               const MethodDescriptor *method) {
  printer->Print("/**\n");
  std::vector<string> lines = GrpcGetDocLinesForDescriptor(method);
  GrpcWriteDocCommentBody(printer, vars, lines, true);
  printer->Print(" */\n");
}

// outputs static singleton extractor for type stored in "extr_type" and
// "extr_type_name" vars
static void PrintTypeExtractor(Printer *p, VARS &vars) {
  p->Print(vars,
           "@Volatile private var extractorOf$extr_type_name$: "
           "FlatbuffersUtils.FBExtactor<$extr_type$>? = null\n"
           "private fun getExtractorOf$extr_type_name$(): "
           "FlatbuffersUtils.FBExtactor<$extr_type$> {\n"
           "    if (extractorOf$extr_type_name$ != null) return "
           "extractorOf$extr_type_name$!!\n"
           "    synchronized ($service_object_name$::class.java) {\n"
           "        if (extractorOf$extr_type_name$ != null) return "
           "extractorOf$extr_type_name$!!\n"
           "            extractorOf$extr_type_name$ = object : "
           "FlatbuffersUtils.FBExtactor<$extr_type$>() {\n"
           "                override public fun extract(buffer: ByteBuffer): $extr_type$ {\n"
           "                    return "
           "$extr_type$.getRootAs$extr_type_name$(buffer);\n"
           "            }\n"
           "        };\n"
           "        return extractorOf$extr_type_name$!!\n"
           "    }\n"
           "}\n\n");
}
static void PrintMethodFields(Printer *p, VARS &vars,
                              const ServiceDescriptor *service) {
  p->Print("// Static method descriptors that strictly reflect the proto.\n");
  vars["service_name"] = service->name();

  // set of names of rpc input- and output- types that were already encountered.
  // this is needed to avoid duplicating type extractor since it's possible that
  // the same type is used as an input or output type of more than a single RPC
  // method
  std::set<std::string> encounteredTypes;

  for (int i = 0; i < service->method_count(); ++i) {
    auto method = service->method(i);
    vars["arg_in_id"] = to_string(2L * i);  // trying to make msvc 10 happy
    vars["arg_out_id"] = to_string(2L * i + 1);
    vars["method_name"] = method->name();
    vars["input_type_name"] = method->get_input_type_name();
    vars["output_type_name"] = method->get_output_type_name();
    vars["input_type"] = KotlinClassName(vars, method->get_input_type_name());
    vars["output_type"] = KotlinClassName(vars, method->get_output_type_name());
    vars["method_field_name"] = MethodPropertiesFieldName(method.get());
    vars["method_new_field_name"] = MethodPropertiesGetterName(method.get());
    vars["method_method_name"] = MethodPropertiesGetterName(method.get());
    bool client_streaming =
        method->ClientStreaming() || method->BidiStreaming();
    bool server_streaming =
        method->ServerStreaming() || method->BidiStreaming();
    if (client_streaming) {
      if (server_streaming) {
        vars["method_type"] = "BIDI_STREAMING";
      } else {
        vars["method_type"] = "CLIENT_STREAMING";
      }
    } else {
      if (server_streaming) {
        vars["method_type"] = "SERVER_STREAMING";
      } else {
        vars["method_type"] = "UNARY";
      }
    }

    if (encounteredTypes.insert(vars["input_type_name"]).second) {
      vars["extr_type"] = vars["input_type"];
      vars["extr_type_name"] = vars["input_type_name"];
      PrintTypeExtractor(p, vars);
    }

    if (encounteredTypes.insert(vars["output_type_name"]).second) {
      vars["extr_type"] = vars["output_type"];
      vars["extr_type_name"] = vars["output_type_name"];
      PrintTypeExtractor(p, vars);
    }

    p->Print(
        vars,
        "@Volatile private var $method_new_field_name$: "
        "$MethodDescriptor$<$input_type$, $output_type$>? = null\n"
        "@$ExperimentalApi$(\"https://github.com/grpc/grpc-java/issues/"
        "1901\")\n"
        "public fun $method_method_name$(): $MethodDescriptor$<\n"
        "    $input_type$, $output_type$> {\n"
        "    var $method_new_field_name$: "
        "$MethodDescriptor$<$input_type$, $output_type$>? = null\n"
        "    $method_new_field_name$ = "
        "$service_object_name$.$method_new_field_name$\n"
        "  if ($method_new_field_name$ == null) {\n"
        "    $method_new_field_name$ = synchronized "
        "($service_object_name$::class.java) {\n"
        "      var result = "
        "$service_object_name$.$method_new_field_name$\n"
        "      if (result == null) {\n"
        "        result = \n "
        "            $MethodDescriptor$.newBuilder<$input_type$, $output_type$>()\n"
        "            .setType($MethodType$.$method_type$)\n"
        "            .setFullMethodName(generateFullMethodName(\n"
        "                \"$Package$$service_name$\", \"$method_name$\"))\n"
        "            .setSampledToLocalTracing(true)\n"
        "            .setRequestMarshaller(FlatbuffersUtils.marshaller(\n"
        "                $input_type$::class.java, "
        "getExtractorOf$input_type_name$()))\n"
        "            .setResponseMarshaller(FlatbuffersUtils.marshaller(\n"
        "                $output_type$::class.java, "
        "getExtractorOf$output_type_name$()))\n"
        "                .setSchemaDescriptor(null)\n"
        "                .build();\n"
        "        $service_object_name$.$method_new_field_name$ = "
        "result\n"
        "        }\n"
        "        return result!!\n");
    p->Print(vars,
             "      }\n"
             "   }\n"
             "   return $method_new_field_name$!!\n"
             "}\n");
  }
}

static void PrintGetServiceDescriptorMethod(Printer *p, VARS &vars,
                                            const ServiceDescriptor *service) {
  vars["service_name"] = service->name();
  p->Print(vars,
           "@Volatile private var serviceDescriptor: $ServiceDescriptor$? = "
           "null\n\n");

  p->Print(vars,
           "fun getServiceDescriptor(): $ServiceDescriptor$ {\n");
  p->Indent();
  p->Print(vars, "var result: $ServiceDescriptor$? = serviceDescriptor\n");
  p->Print("if (result == null) {\n");
  p->Indent();
  p->Print(vars, "synchronized ($service_object_name$::class.java) {\n");
  p->Indent();
  p->Print("result = serviceDescriptor\n");
  p->Print("if (result == null) {\n");
  p->Indent();
  p->Print(vars,
           "result = "
           "$ServiceDescriptor$.newBuilder(SERVICE_NAME)\n");
  p->Indent();
  p->Indent();
  p->Print(vars, "\n.setSchemaDescriptor(null)");
  for (int i = 0; i < service->method_count(); ++i) {
    auto method = service->method(i);
    vars["method_method_name"] = MethodPropertiesGetterName(&*method);
    p->Print(vars, "\n.addMethod($method_method_name$())");
  }
  p->Print("\n.build()\n");
  p->Print(vars, "serviceDescriptor = result\n");
  p->Outdent();
  p->Outdent();

  p->Outdent();
  p->Print("}\n");
  p->Outdent();
  p->Print("}\n");
  p->Outdent();
  p->Print("}\n");
  p->Print("return result!!\n");
  p->Outdent();
  p->Print("}\n");
}

enum StubType {
  ASYNC_INTERFACE = 0,
  BLOCKING_CLIENT_INTERFACE = 1,
  FUTURE_CLIENT_INTERFACE = 2,
  BLOCKING_SERVER_INTERFACE = 3,
  ASYNC_CLIENT_IMPL = 4,
  BLOCKING_CLIENT_IMPL = 5,
  FUTURE_CLIENT_IMPL = 6,
  ABSTRACT_CLASS = 7,
};

enum CallType { ASYNC_CALL = 0, BLOCKING_CALL = 1, FUTURE_CALL = 2 };



static void PrintService(Printer *p, VARS &vars,
                         const ServiceDescriptor *service) {
  vars["service_name"] = service->name();
  vars["service_object_name"] = ServiceObjectName(service->name());
  // TODO(nmittler): Replace with WriteServiceDocComment once included by
  // protobuf distro.
  GrpcWriteServiceDocComment(p, vars, service);
  p->Print(vars,
           "public object $service_object_name$ {\n\n");
  p->Indent();

  p->Print(vars,
           "public const val SERVICE_NAME: $String$ = "
           "\"$Package$$service_name$\"\n\n");

  PrintMethodFields(p, vars, service);

  PrintGetServiceDescriptorMethod(p, vars, service);
  p->Outdent();
  p->Print("}\n");
}

static void PrintKtMethodFields(Printer *p, VARS &vars,
                              const ServiceDescriptor *service) {
  p->Print("// Static method descriptors that strictly reflect the proto.\n");
  vars["service_name"] = service->name();

  // set of names of rpc input- and output- types that were already encountered.
  // this is needed to avoid duplicating type extractor since it's possible that
  // the same type is used as an input or output type of more than a single RPC
  // method
  std::set<std::string> encounteredTypes;

  for (int i = 0; i < service->method_count(); ++i) {
    auto method = service->method(i);
    vars["arg_in_id"] = to_string(2L * i);  // trying to make msvc 10 happy
    vars["arg_out_id"] = to_string(2L * i + 1);
    vars["method_name"] = method->name();
    vars["input_type_name"] = method->get_input_type_name();
    vars["output_type_name"] = method->get_output_type_name();
    vars["input_type"] = KotlinClassName(vars, method->get_input_type_name());
    vars["output_type"] = KotlinClassName(vars, method->get_output_type_name());
    vars["method_field_name"] = MethodPropertiesFieldName(method.get());
    vars["method_new_field_name"] = MethodPropertiesGetterName(method.get());
    vars["method_method_name"] = MethodPropertiesGetterName(method.get());

    p->Print(
        vars,
        "public val $method_field_name$: $MethodDescriptor$<\n"
        "  $input_type$, $output_type$>\n"
        "  @$JvmStatic$\n"
        "  get() = $service_object_name$.$method_method_name$()\n\n");
  }
}

static void PrintBindServiceMethodBody(Printer *p, VARS &vars,
                                       const ServiceDescriptor *service);

// Prints a client interface or implementation class, or a server interface.
static void PrintCoroutineStub(Printer *p, VARS &vars,
                               const ServiceDescriptor *service) {
  const string service_name = service->name();
  vars["service_name"] = service_name;
  vars["service_object_name"] = ServiceObjectName(service_name);

  // Class head
  GrpcWriteServiceDocComment(p, vars, service);
  p->Print(
      vars,
      "@$StubFor$($service_object_name$::class)\n"
      "public class $service_name$CoroutineStub @$JvmOverloads$ constructor(\n"
      "  channel: $Channel$,\n"
      "  callOptions: $CallOptions$ = $CallOptions$.DEFAULT,\n"
      ") : $AbstractCoroutineStub$<$service_name$CoroutineStub>(channel, "
      "callOptions) {\n");
  p->Indent();
  // build method
  p->Print(vars,
           "override fun build(channel: $Channel$, callOptions: "
           "$CallOptions$): $service_name$CoroutineStub =\n"
           "    $service_name$CoroutineStub(channel, callOptions)\n");

  // RPC methods
  for (int i = 0; i < service->method_count(); ++i) {
    auto method = service->method(i);
    vars["input_type"] = KotlinClassName(vars, method->get_input_type_name());
    vars["output_type"] = KotlinClassName(vars, method->get_output_type_name());
    vars["lower_method_name"] = LowerMethodName(&*method);
    vars["method_method_name"] = MethodPropertiesGetterName(&*method);
    bool client_streaming =
        method->ClientStreaming() || method->BidiStreaming();
    bool server_streaming =
        method->ServerStreaming() || method->BidiStreaming();
    vars["suspend"] = "suspend ";
    if (client_streaming) {
      vars["input_type"] = WrapFlow(vars, vars["input_type"]);
      if (server_streaming) {
        vars["method_type"] = "bidiStreamingRpc";
      } else {
        vars["method_type"] = "clientStreamingRpc";
      }
    } else {
      if (server_streaming) {
        vars["method_type"] = "serverStreamingRpc";
      } else {
        vars["method_type"] = "unaryRpc";
      }
    }
    if (server_streaming) {
      vars["suspend"] = "";
      vars["output_type"] = WrapFlow(vars, vars["output_type"]);
    }

    p->Print("\n");
    // TODO(nmittler): Replace with WriteMethodDocComment once included by the
    // protobuf distro.
    GrpcWriteMethodDocComment(p, vars, &*method);
    p->Print(
        vars,
        "public $suspend$fun $lower_method_name$(request: $input_type$, "
        "headers: $Metadata$ = $Metadata$()): $output_type$ = \n"
        "    $method_type$(\n"
        "  channel,\n"
        "  $service_object_name$.$method_method_name$(),\n"
        "  request,\n"
        "  callOptions,\n"
        "  headers\n"
        ")\n");
  }

  p->Outdent();
  p->Print("}\n\n");
}

static void PrintCoroutineImplBase(Printer *p, VARS &vars,
                          const ServiceDescriptor *service) {
  const string service_name = service->name();
  vars["service_name"] = service_name;

  // Class head
  GrpcWriteServiceDocComment(p, vars, service);
  p->Print(
      vars,
      "public abstract class $service_name$CoroutineImplBase(\n"
      "  coroutineContext: $CoroutineContext$ = $EmptyCoroutineContext$,\n"
      ") : $AbstractCoroutineServerImpl$(coroutineContext) {\n");
  p->Indent();

  // RPC methods
  for (int i = 0; i < service->method_count(); ++i) {
    auto method = service->method(i);
    vars["input_type"] = KotlinClassName(vars, method->get_input_type_name());
    vars["output_type"] = KotlinClassName(vars, method->get_output_type_name());
    vars["lower_method_name"] = LowerMethodName(&*method);
    vars["method_method_name"] = MethodPropertiesGetterName(&*method);
    vars["suspend"] = "suspend ";
    bool client_streaming =
        method->ClientStreaming() || method->BidiStreaming();
    bool server_streaming =
        method->ServerStreaming() || method->BidiStreaming();
    if (client_streaming) {
      vars["input_type"] = WrapFlow(vars, vars["input_type"]);
    }
    if (server_streaming) {
      vars["suspend"] = "";
      vars["output_type"] = WrapFlow(vars, vars["output_type"]);
    }


    p->Print("\n");
    // TODO(nmittler): Replace with WriteMethodDocComment once included by the
    // protobuf distro.
    GrpcWriteMethodDocComment(p, vars, &*method);
    p->Print(
        vars,
        "public open $suspend$fun $lower_method_name$(request: $input_type$) "
        ": $output_type$ = throw\n"
        "    $StatusException$(UNIMPLEMENTED.withDescription(\"Method "
        "$Package$$service_name$.$lower_method_name$ is not "
        "implemented\"))\n");
  }
  

  // bindService method
  p->Print(vars,
           "final override fun bindService(): $ServerServiceDefinition$ = "
           "builder($service_object_name$.getServiceDescriptor())\n");
  for (int i = 0; i < service->method_count(); ++i) {
    auto method = service->method(i);
    vars["lower_method_name"] = LowerMethodName(&*method);
    vars["method_method_name"] = MethodPropertiesGetterName(&*method);
    bool client_streaming =
        method->ClientStreaming() || method->BidiStreaming();
    bool server_streaming =
        method->ServerStreaming() || method->BidiStreaming();
    if (client_streaming) {
      if (server_streaming) {
        vars["method_definition"] = "bidiStreamingServerMethodDefinition";
      } else {
        vars["method_definition"] = "clientStreamingServerMethodDefinition";
      }
    } else {
      if (server_streaming) {
        vars["method_definition"] = "serverStreamingServerMethodDefinition";
      } else {
        vars["method_definition"] = "unaryServerMethodDefinition";
      }
    }

    p->Print(vars,
             "  .addMethod($method_definition$(\n"
             "  context = this.context,\n"
             "  descriptor = $service_object_name$.$method_method_name$(),\n"
             "  implementation = ::$lower_method_name$\n"
             "))");
    if (i < service->method_count() - 1) {
      p->Print("\n");
    }
  }
  p->Print(".build()\n");


  p->Outdent();
  p->Print("}\n\n");
}


static void PrintKtService(Printer *p, VARS &vars,
                                  const ServiceDescriptor *service) {
  vars["service_name"] = service->name();
  vars["service_kt_object_name"] = ServiceKtObjectName(service->name());
  vars["service_object_name"] = ServiceObjectName(service->name());
  vars["grpc_version"] = "";
  // TODO(nmittler): Replace with WriteServiceDocComment once included by
  // protobuf distro.
  GrpcWriteServiceDocComment(p, vars, service);
  p->Print(vars,
           "@$GrpcGenerated$\n"
           "public object $service_kt_object_name$ {\n\n");
  p->Indent();
  p->Print(vars, "const val SERVICE_NAME = \"$Package$$service_name$\"\n\n");
  p->Print(
      vars,
      "@$JvmStatic$\n"
      "public val serviceDescriptor: $ServiceDescriptor$\n"
      "  get() = $service_object_name$.getServiceDescriptor()\n\n");

  PrintKtMethodFields(p, vars, service);

  PrintCoroutineStub(p, vars, service);
  PrintCoroutineImplBase(p, vars, service);

  p->Outdent();
  p->Print("}\n");
}

static void PrintStaticImports(Printer *p) {
  p->Print(
      "import java.nio.ByteBuffer\n"
      "import io.grpc.MethodDescriptor.generateFullMethodName\n"
      "import io.grpc.MethodDescriptor.newBuilder\n"
      "import io.grpc.ServerServiceDefinition.builder\n"
      "import io.grpc.Status.UNIMPLEMENTED\n"
      "import io.grpc.kotlin.ClientCalls.bidiStreamingRpc\n"
      "import io.grpc.kotlin.ClientCalls.clientStreamingRpc\n"
      "import io.grpc.kotlin.ClientCalls.serverStreamingRpc\n"
      "import io.grpc.kotlin.ClientCalls.unaryRpc\n"
      "import io.grpc.kotlin.ServerCalls.bidiStreamingServerMethodDefinition\n"
      "import "
      "io.grpc.kotlin.ServerCalls.clientStreamingServerMethodDefinition\n"
      "import "
      "io.grpc.kotlin.ServerCalls.serverStreamingServerMethodDefinition\n"
      "import io.grpc.kotlin.ServerCalls.unaryServerMethodDefinition\n"
  );
}

static void GenerateService(const grpc_generator::Service *service,
                     grpc_generator::Printer *printer, VARS &vars) {
  // All non-generated classes must be referred by fully qualified names to
  // avoid collision with generated classes.
  vars["Channel"] = "io.grpc.Channel";
  vars["CallOptions"] = "io.grpc.CallOptions";
  vars["ExperimentalApi"] = "io.grpc.ExperimentalApi";
  vars["Metadata"] = "io.grpc.Metadata";
  vars["MethodDescriptor"] = "io.grpc.MethodDescriptor";
  vars["MethodType"] = "io.grpc.MethodDescriptor.MethodType";
  vars["ServerServiceDefinition"] = "io.grpc.ServerServiceDefinition";
  vars["ServiceDescriptor"] = "io.grpc.ServiceDescriptor";
  vars["StatusException"] = "io.grpc.StatusException";
  vars["AbstractCoroutineServerImpl"] =
      "io.grpc.kotlin.AbstractCoroutineServerImpl";
  vars["AbstractCoroutineStub"] = "io.grpc.kotlin.AbstractCoroutineStub";
  vars["StubFor"] = "io.grpc.kotlin.StubFor";
  vars["GrpcGenerated"] = "io.grpc.stub.annotations.GrpcGenerated";
  vars["String"] = "kotlin.String";
  vars["CoroutineContext"] = "kotlin.coroutines.CoroutineContext";
  vars["EmptyCoroutineContext"] = "kotlin.coroutines.EmptyCoroutineContext";
  vars["JvmOverloads"] = "kotlin.jvm.JvmOverloads";
  vars["JvmStatic"] = "kotlin.jvm.JvmStatic";
  vars["Flow"] = "kotlinx.coroutines.flow.Flow";

  PrintStaticImports(printer);

  PrintService(printer, vars, service);
  PrintKtService(printer, vars, service);
}
} // namespace

grpc::string GenerateServiceSource(
    grpc_generator::File *file, const grpc_generator::Service *service,
    grpc_kotlin_generator::Parameters *parameters) {
  grpc::string out;
  auto printer = file->CreatePrinter(&out);
  VARS vars;
  vars["flatc_version"] = grpc::string(
      FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR) "." FLATBUFFERS_STRING(
          FLATBUFFERS_VERSION_MINOR) "." FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION));

  vars["file_name"] = file->filename();

  if (!parameters->package_name.empty()) {
    vars["Package"] = parameters->package_name;  // ServiceKotlinPackage(service);
  }
  GenerateImports(file, &*printer, vars);
  GenerateService(service, &*printer, vars);
  return out;
}

}  // namespace grpc_kotlin_generator
